# Graph 응용 - 위상정렬

## Contents
* 위상 정렬
* 위상 정렬(Queue 구현)
* 위상 정렬(Stack 구현)
* 정렬

## 위상 정렬
* <ins>순서가 있는 작업</ins>을 차례로 진행해야 할 때 __순서를 결정__ 해주기 위해 사용하는 알고리즘
* <ins>사이클이 없는 방향 그래프</ins>의 모든 노드를 주어진 방향성에 어긋나지 않게 순서를 나열하는 것
  * __DAG__(Directed Acyclic Graph)
  * ex. 대학 선수과목, 공장 작업 순서, 요리 순서 등
  * 위상정렬 관련 문제는 sample test case가 있고, sample answer가 있을 때, sample answer랑 다를 수 있음.

#### 사전지식 - DAG
* Directed Acyclic Graph(유향 비사이클 그래프)


#### 사전지식 - 차수
* __진입 차수__: 특정 노드로 들어오는 간선의 개수
  * 진입 차수가 의미하는 것이 바로 -> **선행조건의 유무**
* 진출 차수: 특정 노드로 나가는 간선의 개수

## 위상 정렬 방법(Queue 사용)
* 진입 차수가 0인 모든 노드를 Queue에 삽입
* Queue가 공백 상태가 될 때까지 반복 수행
  * Queue에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다. (연결된 노드의 진입 차수를 감소시킨다.)
  * 새롭게 진입 차수가 0이 된 노드를 Queue에 삽입한다.
* Queue에서 꺼내지는 순서(Queue에 들어오는 순서)가 정렬을 수행한 결과

## 위상 정렬 방법(Stack 사용)
1. 진입 차수가 0인 모든 노드에서 DFS 수행
2. DFS 수행
   1. 해당 노드를 **방문 표시**
   2. 인접하면서 방문하지 않은 노드가 있다면 DFS 재귀 호출
   3. 함수 리턴하기 전 Stack에 현재 노드 저장
3. Stack이 공백 상태가 될 때까지 pop

* Stack에서 꺼내지는 순서를 뒤집으면 위상정렬을 수행한 결과가 됨
* System Stack과 ANS Stack이 필요!

### 위상 정렬 특징
* 모든 정점을 방문하기 전에 Queue가 공백 상태가 되면 사이클이 존재하는 것이다.
  * 사이클이 존재하면 진입차수가 0이 될 수 없음
* 그래프의 유형은 DAG
* 여러 해답이 존재할 수 있다.
  * 진입 차숙 0인 값이 동시에 생성이 된다면 작성한 코드 방법에 따라 답이 달라진다.
* 시간 복잡도 O(V+E)


## 정렬 정리
### 1. 버블 정렬
* 구현 방법은 여러 가지가 있다.
* 인접한 두 개 비교
```java
for (int j = 0; j < arr.length - 1; j++) {
    for (int i = 0; i < arr.length - 1 - j; i++) {
        if (arr[i] > arr[i+1]) {
            swap(arr[i], arr[i+1]);
        }
    }
}
```

### 2. 선택 정렬
* 숫자가 쭉 나열되어 있을 때, ex. 0번째 인덱스 값 정렬하고 싶은데 나머지 것들(1번 인덱스~) 중에서 가장 작은 값과 변경

```java
for (int i = 0; i < arr.length-1; i++) {
    int minIdx = i;
    for (int j = i+1; j < arr.length; j++) {
        if (arr[minIdx] > arr[j]) {
            minIdx = j;
        }
    }
    swap(arr[minIdx], arr[i]); // 사이클 당 swap 1번 일어남
}
```


### 3. 카운팅 정렬
1. 먼저, for문 돌면서 가장 큰 값(maxVal) 찾기
1. 0 또는 양의 정수일 떄만 가능한 정렬
1. maxVal+1 칸의 배열 만들기
     *  각 값이 몇 개 나오는지 값의 개수 저장
2. 누적합 저장 
3. 뒤에서부터 새로운 배열에 정렬된 위치 저장
      * 누적합의 값 --

### 4. 삽입정렬
* 배우기 전부터 써왔던 것! ex. 원카드, 도둑잡기...
* 넣고 뒤로 밀기!!
  * 69, 10, 30 -> 10 정렬하자
  * 10, 69, 30 -> 30 정렬하자
  * 10, 30, 69


### 5. 힙 정렬
* 최대힙, 최소힙, PriorityQueue
* 전부 다 집어넣고 전부 다 빼야 함
* 항상 root에 있는 애가 삭제되고, 마지막에 있는 애가 올라가서 다시 비교하며 내려가는 방식


### 6. 병합 정렬
* 안정 정렬
* 시간 무조건 $O(NlonN)$ 보장

### 7. 퀵 정렬
* pivot을 기준으로 왼쪽과 오른쪽을 나눔
  * 한 사이클이 끝나면 pivot은 정렬되어 있음
  * 나머지 두 개의 부분에 대해 퀵 정렬을 수행
* 호어 파티션
* 로무토 파티션
* 시간복잡도 평균적으로 $O(NlogN)$, 최악의 경우 $O(N^2)$
  *  최악의 경우 -> pivot이 계속 한 칸씩만 이동할 때


### 8. 위상 정렬
* 이름만 정렬이지, 위 정렬들과는 의미가 다소 다름


### 9. Arrays.sort()
* 배열을 가지고 정렬할 때
* 숫자, 문자열에 대한 정렬 기준 정해져 있으나
* 직접 만든 class, edge를 정렬하기 위해서 혹은 새로운 기준을 만들고자 할 때는 comparator와 comparable 사용
  * comparator - 인자가 2개 들어옴 `comparator(얘, 쟤)`
  * `comparable(얘)`

### 10. Collections.sort()
* 리스트를 정렬할 때
* 숫자, 문자열에 대한 정렬 기준 정해져 있으나
* 직접 만든 class, edge를 정렬하기 위해서 혹은 새로운 기준을 만들고자 할 때는 comparator와 comparable 사용
  * comparator - 인자가 2개 들어옴 `comparator(얘, 쟤)`
  * `comparable(얘)`