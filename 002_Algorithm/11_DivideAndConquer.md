# Divide and Conquer

## Contents
* 분할정복(divide and conquer)
* 이진 검색(binary search)
* 병합 정렬(merge sort)
* 퀵 정렬(quick sort)

## 분할정복(divide and conquer)
* 큰 문제를 작은 하위 문제로 나누어 해결하는 방식
* 과거의 군사적인 유래부터 현대의 컴퓨터과학에서 응용까지 활용되는 개념

### 설계 전략
* 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눈다.
* 정복(Conquer): 나눈 작은 문제를 각각 해결한다.
* 결합(Combine): (필요하다면) 해결된 해답을 모은다.
  * 병합 정렬 -> 결합 필요
  * 퀵 정렬 -> 결합 불필요


### Top-down approach

<img src = "https://www.interviewbit.com/blog/wp-content/uploads/2022/06/What-is-Divide-and-Conquer-768x599.png" width = 500>

<br>



## 이진 검색(binary search)
* <ins>(전제조건) 정렬된</ins> 배열에서 특정한 값을 빠르게 찾기 위한 알고리즘
* 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

### 검색 과정
1. 중앙 값 찾기
2. 목표 값과 중앙 값 비교
   * 목표 값과 중앙 값이 같은 경우: 검색 종료
   * 목표 값이 중앙 값보다 작을 경우: 왼쪽 절반 검색 수행
   * 목표 값이 중앙 값보다 클 경우: 오른쪽 절반 검색 수행


### 이진 검색 정리
* 시간복잡도$O(logN)$ -> 1000개의 원소를 대략 10번 정도의 비교로 값을 찾을 수 있음
* 미리 정렬이 되어 있어야 함. (데이터의 삽입, 삭제가 자주 일어나면 정렬해야 하므로 비효율적일 수 있음)
* 크기가 작은 배열에서는 크게 이점이 없을 수 있음

#### 심화
* java.util.Arrays.binarySearch 메서드
* BST(Binary Search Tree)
* 이진 검색 응용 -> Lower Bound, Upper Bound


## 병합 정렬(merge sort)
* 분할 정복 기법을 활용한 안정적인 정렬 알고리즘
* 배열을 절반으로 분할하고, 각 부분을 재귀적으로 정렬한 뒤, 정렬된 부분 배열을 다시 병합하는 정렬 방식
* 시간 복잡도 $O(N logN)$
* 추가적인 공간 필요

### 단계별 동작
* 분할(Divide): 주어진 배열을 반으로 나눈다.
* 정복(Conquer): 각 부분 배열을 재귀적으로 병합 정렬을 사용해 정렬한다.
* 병합(Combine): 정렬된 부분 배열들을 합쳐 전체 배열을 정렬한다.

```java
mergeSort(arr[], left, right) {
    if (left < right) {
        mid = (left + right) / 2;

    }
        
}
```

## 퀵 정렬(quick sort)

* 분할 정복 기법을 활용한 효율적인 정렬 알고리즘
* 피벗이라는 기준 요소를 선택하여 배열을 두 부분으로 분할하고, 재귀적으로 정렬하는 방식
* 시간복잡도 $O(NlogN)$, 최악에는 $O(N^2)$
* 추가적인 공간을 필요치 않아 함


### 단계별 동작
* Pivot 결정(여러 개의 선정하는 방법이 존재)
* 분할: Pivot보다 작은 요소는 왼쪽에, 큰 요소는 오른쪽에 위치하도록 배열 나누기
* 정복: 분할된 배열을 다시 재귀적으로 정복
* 병합(Combine): 따로 필요치 X (이미 정렬 완료)


### 퀵 정렬 아이디어


### 퀵 정렬 과정 (Hoare 파티션)
* 피벗 선택하기
  1. __첫 번쨰 요소 선택__
  2. 마지막 요소 선택
  3. 중간 요소 선택
  4. 랜덤 요소 선택
  5. 세 값의 중앙 값 선택