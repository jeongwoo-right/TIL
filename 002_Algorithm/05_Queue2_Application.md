# Queue

### Contents

* Review
* 원형큐
* 우선순위 큐
* 삽입정렬

<br>

## Review

### 선형 큐

* 기능  
  * 삽입: rear++
  * 삭제: front++
  * isEmpty: rear == front 
  * isFull: 
  * size
* 문제점
  * 잘못된 포화상태 인식
  * 실제로는 들어갈 공간이 있음에도 포화상태로 인식하여 데이터를 삽입할 수 없음
  * 원형큐를 사용하여 문제를 해결할 수 있다


### 정렬
- 버블 정렬
- 선택 정렬
- 카운팅 정렬

<br>

## 원형 큐

### 원형 큐의 구조
* 초기 공백 상태
  * front = rear = 0
* Index의 순환
  * front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
  * 이를 위해 나머지 연산자 mod를 사용함.

* 여전히 발생할 수 있는 문제점
  * full과 empty 상태를 구분할 수 없음

* front 변수
  * 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
    * 공백상태: front == rear
    * 포화상태: front가 rear 한 칸 앞인가?
      * $(N+front-rear)%4$ == 1 


### 원형 큐의 연산 과정
1. create Queue
2. enQueue(A) 
3. 
4. 
5. enQueue(C); 
6. enQueue(D);

<br>

## 우선순위 큐

### 우선순위 큐의 특성
* 우선순위를 가진 항목들을 저장하는 큐
* FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.

### 우선순위 큐의 적용 분야
* 시뮬레이션 시스템
* 네트워크 트래픽 제어
* 운영체제의 task scheduling

### 우선순위 큐의 구현
* 배열을 이용한 우선순위 큐
* 리스트를 이용한 우선순위 큐

### 우선순위 큐의 기본 연산
* 삽입: enQueue
* 삭제: deQueue

### 배열을 이용하여 우선순위 큐 구현
* 배열을 이용하여 자료 저장
* 원소를 삽입하는 괒어에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
* 가장 앞에 최고 우선순위의 원소가 위치하게 됨


### 문제점
* 배열에 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
* 이에 소요되는 시간이나 메모리 낭비가 큼

<br>

## 삽입정렬
* 도서관 사서가 책을 정렬할 때, 일반적으로 활용되는 방식
* 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성


### 정렬 과정
* 정렬할 자료를 두 개의 부분집합 S와 U로 가정
  * 부분집합 S: 정렬된 앞부분의 원소들
  * 부분집합 U: 아직 정렬되지 않은 나머지 원소들
* 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입한다.
* 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 된다. 부분집합 U가 공집합이 되면 삽입정렬이 완성된다.