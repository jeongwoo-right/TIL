# Backtracking

## Contents
* 백트래킹
* 순열


## 백트래킹
* 가능한 모든 경우를 탐색하는 중 해답으로 이어지지 않은 경우에 대해서는 탐색하지 않고 되돌아가며 해결하는 알고리즘 기법
* __유망(promising)__: 현재 상태(노드, 경로)가 문제의 해답으로 발전할 가능성이 높은지를 판단하는 기준
* __가지치기(pruning)__: 탐색 중 불필요한 경로를 제거하여 탐색의 효율성을 높이는 방법

### 완전 탐색 vs 백트래킹
* 모든 경우의 수를 고려하는 완전 탐색(브루트포스)와는 달리, 모든 경우의 수를 고려하지 않음
* 일반적으로 경우의 수가 줄어들지만, 최악의 경우에는 여전히 지수함수 시간을 요하므로 해결이 불가능
    1. 가지치기가 거의 이루어지지 않은 상황
    2. 문제가 매우 큰 입력을 가지는 상황
    3. 유효한 해답이 거의 없는 상황
    4. ...

###  N-Queen 문제
#### 8-Qeen 문제
* $8 \times 8$ 크기의 체스판 위에 8개의 Queen들을 서로 위협하지 않게 배치하는 모든 경우의 수를 구하는 문제
* 모든 경우의 수는 $_{64}C_{8} = 4,426,165,368$
* 실제 정답의 수는 92개
* 모든 경우의 수 속에서 92개를 최대한 효율적으로 찾아내는 것이 관건

#### 4-Queen 문제
* 같은 행에는 퀸을 놓을 수 없음
* 따라서 모든 경우의 수는 $4 \times 4 \times 4 \times 4 = 256$ 가지
* 재귀함수를 이용하여 구현해보자
  * 상태공간트리
* 모든 경우의 수를 탐색하였을 때 해답이 될 가능성이 전혀 없는 경우의 수들도 검색해야 하므로 비효율적
* 해당 노드의 유망성을 판단하고 백트래킹을 적용하여 해결해보자

```java
NQueen(node v) {
    IF promising(v)
        IF there is a solution at v
            write the solution
        ELSE
            FOR each child u of v
                NQueen(u)
}
```


<br><br>

## 순열



### 문제 제시: 라면 끓이기
* 재료
  * water
  * soup base
  * noodles
* 라면을 끓이는 방법: 총 $3!=6$


### 순열(Permutation)
* 순열: 서로 다른 원소들을 특정한 순서로 나열하는 것
* 서로 다른 n개의 원소를 가지는 집합에서 r개를 뽑아 순서 있게 나열하는 경우를 다음과 같이 표현할 수 있음
  * $_{n}P_{r} = n \times (n-1)  \times (n-2)  \times ...  \times (n-r+1)$

### N의 범위에 따른 순열의 수
* N > 12인 경우, 시간 복잡도 폭발적으로 증가
* 보통, 순열로 푸는 문제의 경우, 12를 넘어가지 않는 경우가 많음.


### 순열 구현

1. 반복문
2. swap

<img src = "https://velog.velcdn.com/images%2Fsoyeon207%2Fpost%2Fabf3b393-cf99-413b-91de-9219adefc173%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.44.52.png" width = 800>
